/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Inject, Optional } from '@angular/core';
import { filter, map, tap } from 'rxjs/operators';
import { HIGHLIGHT_OPTIONS } from './highlight.model';
import { HighlightLoader } from './highlight.loader';
import * as i0 from "@angular/core";
import * as i1 from "./highlight.loader";
import * as i2 from "./highlight.model";
export class HighlightJS {
    /**
     * @param {?} _loader
     * @param {?} options
     */
    constructor(_loader, options) {
        this._loader = _loader;
        // Load highlight.js library on init
        _loader.ready.pipe().subscribe((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => {
            this._hljs = hljs;
            if (options && options.config) {
                // Set global config if present
                hljs.configure(options.config);
                if (hljs.listLanguages().length < 1) {
                    console.error('[HighlightJS]: No languages were registered!');
                }
            }
        }));
    }
    // A reference for hljs library
    /**
     * @return {?}
     */
    get hljs() {
        return this._hljs;
    }
    /**
     * Core highlighting function.
     * @param {?} name Accepts a language name, or an alias
     * @param {?} value A string with the code to highlight.
     * @param {?} ignore_illegals When present and evaluates to a true value, forces highlighting to finish
     * even in case of detecting illegal syntax for the language instead of throwing an exception.
     * @param {?=} continuation An optional mode stack representing unfinished parsing.
     * When present, the function will restart parsing from this state instead of initializing a new one
     * @return {?}
     */
    highlight(name, value, ignore_illegals, continuation) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.highlight(name, value, ignore_illegals, continuation))));
    }
    /**
     * Highlighting with language detection.
     * @param {?} value Accepts a string with the code to highlight
     * @param {?} languageSubset An optional array of language names and aliases restricting detection to only those languages.
     * The subset can also be set with configure, but the local parameter overrides the option if set.
     * @return {?}
     */
    highlightAuto(value, languageSubset) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.highlightAuto(value, languageSubset))));
    }
    /**
     * Post-processing of the highlighted markup.
     * Currently consists of replacing indentation TAB characters and using <br> tags instead of new-line characters.
     * Options are set globally with configure.
     * @param {?} value Accepts a string with the highlighted markup
     * @return {?}
     */
    fixMarkup(value) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.fixMarkup(value))));
    }
    /**
     * Applies highlighting to a DOM node containing code.
     * The function uses language detection by default but you can specify the language in the class attribute of the DOM node.
     * See the class reference for all available language names and aliases.
     * @param {?} block The element to apply highlight on.
     * @return {?}
     */
    highlightBlock(block) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.highlightBlock(block))));
    }
    /**
     * Configures global options:
     * @param {?} config HighlightJs configuration argument
     * @return {?}
     */
    configure(config) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.configure(config))));
    }
    /**
     * Applies highlighting to all <pre><code>..</code></pre> blocks on a page.
     * @return {?}
     */
    initHighlighting() {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.initHighlighting())));
    }
    /**
     * Adds new language to the library under the specified name. Used mostly internally.
     * @param {?} name A string with the name of the language being registered
     * @param {?} language A function that returns an object which represents the language definition.
     * The function is passed the hljs object to be able to use common regular expressions defined within it.
     * @return {?}
     */
    registerLanguage(name, language) {
        return this._loader.ready.pipe(tap((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.registerLanguage(name, language))));
    }
    /**
     * @return {?} The languages names list.
     */
    listLanguages() {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.listLanguages())));
    }
    /**
     * Looks up a language by name or alias.
     * @param {?} name Language name
     * @return {?} The language object if found, undefined otherwise.
     */
    getLanguage(name) {
        return this._loader.ready.pipe(map((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.getLanguage(name))));
    }
    /**
     * Display line numbers
     * @param {?} el Code element
     * @return {?}
     */
    lineNumbersBlock(el) {
        return this._loader.ready.pipe(filter((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => !!hljs.lineNumbersBlock)), tap((/**
         * @param {?} hljs
         * @return {?}
         */
        (hljs) => hljs.lineNumbersBlock(el))));
    }
}
HighlightJS.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
HighlightJS.ctorParameters = () => [
    { type: HighlightLoader },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HIGHLIGHT_OPTIONS,] }] }
];
/** @nocollapse */ HighlightJS.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function HighlightJS_Factory() { return new HighlightJS(i0.ɵɵinject(i1.HighlightLoader), i0.ɵɵinject(i2.HIGHLIGHT_OPTIONS, 8)); }, token: HighlightJS, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    HighlightJS.prototype._hljs;
    /**
     * @type {?}
     * @private
     */
    HighlightJS.prototype._loader;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGlnaGxpZ2h0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtaGlnaGxpZ2h0anMvIiwic291cmNlcyI6WyJsaWIvaGlnaGxpZ2h0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU3RCxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQXdFLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDNUgsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDOzs7O0FBS3JELE1BQU0sT0FBTyxXQUFXOzs7OztJQVN0QixZQUFvQixPQUF3QixFQUF5QyxPQUF5QjtRQUExRixZQUFPLEdBQVAsT0FBTyxDQUFpQjtRQUMxQyxvQ0FBb0M7UUFDcEMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxTQUFTOzs7O1FBQUMsQ0FBQyxJQUFzQixFQUFFLEVBQUU7WUFDeEQsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDbEIsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtnQkFDN0IsK0JBQStCO2dCQUMvQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDL0IsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDbkMsT0FBTyxDQUFDLEtBQUssQ0FBQyw4Q0FBOEMsQ0FBQyxDQUFDO2lCQUMvRDthQUNGO1FBQ0gsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7OztJQWhCRCxJQUFJLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQzs7Ozs7Ozs7Ozs7SUF5QkQsU0FBUyxD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QUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsRUFBQyxDQUMzRCxDQUFDO0lBQ0osQ0FBQzs7O1lBeklGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OztZQUpRLGVBQWU7NENBY3lCLFFBQVEsWUFBSSxNQUFNLFNBQUMsaUJBQWlCOzs7Ozs7OztJQVBuRiw0QkFBaUM7Ozs7O0lBT3JCLDhCQUFnQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBIaWdobGlnaHRDb25maWcsIEhpZ2hsaWdodFJlc3VsdCwgSGlnaGxpZ2h0TGlicmFyeSwgSGlnaGxpZ2h0T3B0aW9ucywgSElHSExJR0hUX09QVElPTlMgfSBmcm9tICcuL2hpZ2hsaWdodC5tb2RlbCc7XHJcbmltcG9ydCB7IEhpZ2hsaWdodExvYWRlciB9IGZyb20gJy4vaGlnaGxpZ2h0LmxvYWRlcic7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBIaWdobGlnaHRKUyB7XHJcblxyXG4gIHByaXZhdGUgX2hsanMhOiBIaWdobGlnaHRMaWJyYXJ5O1xyXG5cclxuICAvLyBBIHJlZmVyZW5jZSBmb3IgaGxqcyBsaWJyYXJ5XHJcbiAgZ2V0IGhsanMoKTogSGlnaGxpZ2h0TGlicmFyeSB8IG51bGwge1xyXG4gICAgcmV0dXJuIHRoaXMuX2hsanM7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2FkZXI6IEhpZ2hsaWdodExvYWRlciwgQE9wdGlvbmFsKCkgQEluamVjdChISUdITElHSFRfT1BUSU9OUykgb3B0aW9uczogSGlnaGxpZ2h0T3B0aW9ucykge1xyXG4gICAgLy8gTG9hZCBoaWdobGlnaHQuanMgbGlicmFyeSBvbiBpbml0XHJcbiAgICBfbG9hZGVyLnJlYWR5LnBpcGUoKS5zdWJzY3JpYmUoKGhsanM6IEhpZ2hsaWdodExpYnJhcnkpID0+IHtcclxuICAgICAgdGhpcy5faGxqcyA9IGhsanM7XHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29uZmlnKSB7XHJcbiAgICAgICAgLy8gU2V0IGdsb2JhbCBjb25maWcgaWYgcHJlc2VudFxyXG4gICAgICAgIGhsanMuY29uZmlndXJlKG9wdGlvbnMuY29uZmlnKTtcclxuICAgICAgICBpZiAoaGxqcy5saXN0TGFuZ3VhZ2VzKCkubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0hpZ2hsaWdodEpTXTogTm8gbGFuZ3VhZ2VzIHdlcmUgcmVnaXN0ZXJlZCEnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29yZSBoaWdobGlnaHRpbmcgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtIG5hbWUgQWNjZXB0cyBhIGxhbmd1YWdlIG5hbWUsIG9yIGFuIGFsaWFzXHJcbiAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gaGlnaGxpZ2h0LlxyXG4gICAqIEBwYXJhbSBpZ25vcmVfaWxsZWdhbHMgV2hlbiBwcmVzZW50IGFuZCBldmFsdWF0ZXMgdG8gYSB0cnVlIHZhbHVlLCBmb3JjZXMgaGlnaGxpZ2h0aW5nIHRvIGZpbmlzaFxyXG4gICAqIGV2ZW4gaW4gY2FzZSBvZiBkZXRlY3RpbmcgaWxsZWdhbCBzeW50YXggZm9yIHRoZSBsYW5ndWFnZSBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGV4Y2VwdGlvbi5cclxuICAgKiBAcGFyYW0gY29udGludWF0aW9uIEFuIG9wdGlvbmFsIG1vZGUgc3RhY2sgcmVwcmVzZW50aW5nIHVuZmluaXNoZWQgcGFyc2luZy5cclxuICAgKiBXaGVuIHByZXNlbnQsIHRoZSBmdW5jdGlvbiB3aWxsIHJlc3RhcnQgcGFyc2luZyBmcm9tIHRoaXMgc3RhdGUgaW5zdGVhZCBvZiBpbml0aWFsaXppbmcgYSBuZXcgb25lXHJcbiAgICovXHJcbiAgaGlnaGxpZ2h0KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgaWdub3JlX2lsbGVnYWxzOiBib29sZWFuLCBjb250aW51YXRpb24/OiBhbnkpOiBPYnNlcnZhYmxlPEhpZ2hsaWdodFJlc3VsdD4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlci5yZWFkeS5waXBlKFxyXG4gICAgICBtYXAoKGhsanM6IEhpZ2hsaWdodExpYnJhcnkpID0+IGhsanMuaGlnaGxpZ2h0KG5hbWUsIHZhbHVlLCBpZ25vcmVfaWxsZWdhbHMsIGNvbnRpbnVhdGlvbikpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgZGV0ZWN0aW9uLlxyXG4gICAqIEBwYXJhbSB2YWx1ZSBBY2NlcHRzIGEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XHJcbiAgICogQHBhcmFtIGxhbmd1YWdlU3Vic2V0IEFuIG9wdGlvbmFsIGFycmF5IG9mIGxhbmd1YWdlIG5hbWVzIGFuZCBhbGlhc2VzIHJlc3RyaWN0aW5nIGRldGVjdGlvbiB0byBvbmx5IHRob3NlIGxhbmd1YWdlcy5cclxuICAgKiBUaGUgc3Vic2V0IGNhbiBhbHNvIGJlIHNldCB3aXRoIGNvbmZpZ3VyZSwgYnV0IHRoZSBsb2NhbCBwYXJhbWV0ZXIgb3ZlcnJpZGVzIHRoZSBvcHRpb24gaWYgc2V0LlxyXG4gICAqL1xyXG4gIGhpZ2hsaWdodEF1dG8odmFsdWU6IHN0cmluZywgbGFuZ3VhZ2VTdWJzZXQ6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxIaWdobGlnaHRSZXN1bHQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIucmVhZHkucGlwZShcclxuICAgICAgbWFwKChobGpzOiBIaWdobGlnaHRMaWJyYXJ5KSA9PiBobGpzLmhpZ2hsaWdodEF1dG8odmFsdWUsIGxhbmd1YWdlU3Vic2V0KSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3N0LXByb2Nlc3Npbmcgb2YgdGhlIGhpZ2hsaWdodGVkIG1hcmt1cC5cclxuICAgKiBDdXJyZW50bHkgY29uc2lzdHMgb2YgcmVwbGFjaW5nIGluZGVudGF0aW9uIFRBQiBjaGFyYWN0ZXJzIGFuZCB1c2luZyA8YnI+IHRhZ3MgaW5zdGVhZCBvZiBuZXctbGluZSBjaGFyYWN0ZXJzLlxyXG4gICAqIE9wdGlvbnMgYXJlIHNldCBnbG9iYWxseSB3aXRoIGNvbmZpZ3VyZS5cclxuICAgKiBAcGFyYW0gdmFsdWUgQWNjZXB0cyBhIHN0cmluZyB3aXRoIHRoZSBoaWdobGlnaHRlZCBtYXJrdXBcclxuICAgKi9cclxuICBmaXhNYXJrdXAodmFsdWU6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLnJlYWR5LnBpcGUoXHJcbiAgICAgIG1hcCgoaGxqczogSGlnaGxpZ2h0TGlicmFyeSkgPT4gaGxqcy5maXhNYXJrdXAodmFsdWUpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGEgRE9NIG5vZGUgY29udGFpbmluZyBjb2RlLlxyXG4gICAqIFRoZSBmdW5jdGlvbiB1c2VzIGxhbmd1YWdlIGRldGVjdGlvbiBieSBkZWZhdWx0IGJ1dCB5b3UgY2FuIHNwZWNpZnkgdGhlIGxhbmd1YWdlIGluIHRoZSBjbGFzcyBhdHRyaWJ1dGUgb2YgdGhlIERPTSBub2RlLlxyXG4gICAqIFNlZSB0aGUgY2xhc3MgcmVmZXJlbmNlIGZvciBhbGwgYXZhaWxhYmxlIGxhbmd1YWdlIG5hbWVzIGFuZCBhbGlhc2VzLlxyXG4gICAqIEBwYXJhbSBibG9jayBUaGUgZWxlbWVudCB0byBhcHBseSBoaWdobGlnaHQgb24uXHJcbiAgICovXHJcbiAgaGlnaGxpZ2h0QmxvY2soYmxvY2s6IEhUTUxFbGVtZW50KTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLnJlYWR5LnBpcGUoXHJcbiAgICAgIG1hcCgoaGxqczogSGlnaGxpZ2h0TGlicmFyeSkgPT4gaGxqcy5oaWdobGlnaHRCbG9jayhibG9jaykpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlndXJlcyBnbG9iYWwgb3B0aW9uczpcclxuICAgKiBAcGFyYW0gY29uZmlnIEhpZ2hsaWdodEpzIGNvbmZpZ3VyYXRpb24gYXJndW1lbnRcclxuICAgKi9cclxuICBjb25maWd1cmUoY29uZmlnOiBIaWdobGlnaHRDb25maWcpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIucmVhZHkucGlwZShcclxuICAgICAgbWFwKChobGpzOiBIaWdobGlnaHRMaWJyYXJ5KSA9PiBobGpzLmNvbmZpZ3VyZShjb25maWcpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGxpZXMgaGlnaGxpZ2h0aW5nIHRvIGFsbCA8cHJlPjxjb2RlPi4uPC9jb2RlPjwvcHJlPiBibG9ja3Mgb24gYSBwYWdlLlxyXG4gICAqL1xyXG4gIGluaXRIaWdobGlnaHRpbmcoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLnJlYWR5LnBpcGUoXHJcbiAgICAgIG1hcCgoaGxqczogSGlnaGxpZ2h0TGlicmFyeSkgPT4gaGxqcy5pbml0SGlnaGxpZ2h0aW5nKCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBuZXcgbGFuZ3VhZ2UgdG8gdGhlIGxpYnJhcnkgdW5kZXIgdGhlIHNwZWNpZmllZCBuYW1lLiBVc2VkIG1vc3RseSBpbnRlcm5hbGx5LlxyXG4gICAqIEBwYXJhbSBuYW1lIEEgc3RyaW5nIHdpdGggdGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGJlaW5nIHJlZ2lzdGVyZWRcclxuICAgKiBAcGFyYW0gbGFuZ3VhZ2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24uXHJcbiAgICogVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgaGxqcyBvYmplY3QgdG8gYmUgYWJsZSB0byB1c2UgY29tbW9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZGVmaW5lZCB3aXRoaW4gaXQuXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJMYW5ndWFnZShuYW1lOiBzdHJpbmcsIGxhbmd1YWdlOiAoKSA9PiBhbnkpOiBPYnNlcnZhYmxlPEhpZ2hsaWdodExpYnJhcnk+IHtcclxuICAgIHJldHVybiB0aGlzLl9sb2FkZXIucmVhZHkucGlwZShcclxuICAgICAgdGFwKChobGpzOiBIaWdobGlnaHRMaWJyYXJ5KSA9PiBobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UobmFtZSwgbGFuZ3VhZ2UpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4gVGhlIGxhbmd1YWdlcyBuYW1lcyBsaXN0LlxyXG4gICAqL1xyXG4gIGxpc3RMYW5ndWFnZXMoKTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlci5yZWFkeS5waXBlKFxyXG4gICAgICBtYXAoKGhsanM6IEhpZ2hsaWdodExpYnJhcnkpID0+IGhsanMubGlzdExhbmd1YWdlcygpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExvb2tzIHVwIGEgbGFuZ3VhZ2UgYnkgbmFtZSBvciBhbGlhcy5cclxuICAgKiBAcGFyYW0gbmFtZSBMYW5ndWFnZSBuYW1lXHJcbiAgICogQHJldHVybiBUaGUgbGFuZ3VhZ2Ugb2JqZWN0IGlmIGZvdW5kLCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAqL1xyXG4gIGdldExhbmd1YWdlKG5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLnJlYWR5LnBpcGUoXHJcbiAgICAgIG1hcCgoaGxqczogSGlnaGxpZ2h0TGlicmFyeSkgPT4gaGxqcy5nZXRMYW5ndWFnZShuYW1lKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwbGF5IGxpbmUgbnVtYmVyc1xyXG4gICAqIEBwYXJhbSBlbCBDb2RlIGVsZW1lbnRcclxuICAgKi9cclxuICBsaW5lTnVtYmVyc0Jsb2NrKGVsOiBIVE1MRWxlbWVudCk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyLnJlYWR5LnBpcGUoXHJcbiAgICAgIGZpbHRlcigoaGxqczogSGlnaGxpZ2h0TGlicmFyeSkgPT4gISFobGpzLmxpbmVOdW1iZXJzQmxvY2spLFxyXG4gICAgICB0YXAoKGhsanM6IEhpZ2hsaWdodExpYnJhcnkpID0+IGhsanMubGluZU51bWJlcnNCbG9jayhlbCkpXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=